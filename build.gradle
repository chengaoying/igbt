apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'eclipse'
apply plugin: 'maven'

final env = System.getenv()

sourceCompatibility = '1.3'
targetCompatibility = '1.1'

configurations {
	allInOne
	publish
	wtkProvide
	refProvide
	compile.extendsFrom(refProvide)
	compile.extendsFrom(wtkProvide)
}

repositories {
	flatDir name: 'wtk', dirs: "${env.WTK_HOME}/lib"
	mavenLocal()
	maven {
		url 'http://localhost:8000/nexus/content/groups/public/'
	}
	//mavenCentral()
}

dependencies {
	wtkProvide ':cldcapi11:@jar'
	wtkProvide ':midpapi20:@jar'
}

compileJava {
	options.encoding = 'gbk'
	options.bootClasspath = configurations.wtkProvide.inject(""){a, b -> a+b+':'}
}

task preverify(type: Exec) {
	dependsOn compileJava
	destinationDir = "${buildDir}/iptv/classes"
	executable "${env.WTK_HOME}/bin/preverify"
	args '-classpath', configurations.compile.inject(""){a, b -> a+b+';'}
	args '-d', destinationDir
	args '-target', 'CLDC1.1'
	args compileJava.destinationDir
}

def validprop(name) {
	if (hasProperty(name)) {
		property(name)
	}
	else {
		""
	}
}

def renderTemplate(text, binding) {
	def engine = new groovy.text.SimpleTemplateEngine()
	def template = engine.createTemplate(text).make(binding)
	template.toString()
}

def renderTemplateFile(f, binding) {
	def text = f instanceof File ? f.getText() : file(f).getText()
	renderTemplate(text, binding)
}

task configjme {
	onlyIf {
		hasProperty('telcom')&&hasProperty('sp')&&hasProperty('midlet')
	}
	binding = project.properties
}

configjme << {
	if (file("${env.SGBT_HOME}/conf/${telcom}-${sp}.conf").exists()) {
		def text = renderTemplateFile("${env.SGBT_HOME}/conf/${telcom}-${sp}.conf", binding)
		file("${buildDir}/iptv/resources/conf/game.conf").write(text)
	}
	else {
		def text1 = renderTemplateFile("${env.SGBT_HOME}/conf/${telcom}.conf", binding)
		def text2 = renderTemplateFile("${env.SGBT_HOME}/conf/${sp}.conf", binding)
		file("${buildDir}/iptv/resources/conf/game.conf").write(text1+text2)
	}
}

task resjme(type: Copy) {
	dependsOn configjme
  dependsOn processResources
  from processResources.destinationDir
  into "${buildDir}/iptv/resources"
}

def writeAppDesc(f) {
	def file = f instanceof File ? f : file(f)
	file.write """MIDlet-Version: 1.0.0
MIDlet-Vendor: MIDlet Suite Vendor
MIDlet-Jar-URL: ${uberjme.archiveName}
MicroEdition-Configuration: CLDC-1.1
MicroEdition-Profile: MIDP-2.0
MIDlet-Name: ${archivesBaseName} MIDlet Suite
"""
	if (hasProperty('midlet')) {
		file.append("MIDlet-1: ${archivesBaseName}MIDlet,,${midlet}\r\n")
	}
}

task jarjme(type: Jar) {
	dependsOn preverify
  dependsOn resjme
	from preverify.destinationDir
	from resjme.destinationDir
	destinationDir = file("${buildDir}/iptv/jar")
}

task uberjme(type: Jar) {
	dependsOn preverify
  dependsOn resjme
	from configurations.refProvide.collect { it.isDirectory() ? it : zipTree(it) }
	from preverify.destinationDir
	from resjme.destinationDir
	destinationDir = file("${buildDir}/iptv/uberjar")
}

task obfuscate(type: Exec) {
	dependsOn uberjme
	destinationPath = "${buildDir}/iptv/publish"
	archivePath = destinationPath+"/"+uberjme.archiveName
	executable "${env.PROGUARD_HOME}/bin/proguard.bat"
	args '-injars', uberjme.archivePath
	args '-outjars', archivePath
	configurations.wtkProvide.each {args '-libraryjars', it }
	args "-repackageclasses ''"
	args '-overloadaggressively'
	args '-microedition'
	args '-keep', 'public class * extends javax.microedition.midlet.MIDlet'
}

def jadName(name) {
	name[0..<name.length]+"d"
}

task jadjme {
	jadName = jadName(uberjme.archiveName)
	jadPath = jadName(obfuscate.archivePath)
	doLast {
		writeAppDesc(obfuscate.destinationDir)
	}
}

task publish {
	dependsOn obfuscate
	dependsOn jadjme
}

task testjme(type: JavaExec) {
	dependsOn test
	dependsOn uberjme
	dependsOn jadjme
	main = "org.microemu.app.Main"
	args '--resizableDevice 640 530'
	args jadjme.jadPath
	classpath "${env.SGBT_HOME}/lib/microemulator.jar"
	classpath uberjme.archivePath
}

task pngout(type: Exec) {
	executable "${env.SGBT_HOME}/bin/pngout.bat"
	args sourceSets.main.resources.srcDir
}

artifacts {
  archives jarjme.archivePath
  allInOne uberjme.archivePath
  publish obfuscate.archivePath
}

uploadArchives {
	dependsOn jarjme
	repositories {
    mavenDeployer {
  		if (validprop('releaseRepos')) {
        repository(url: releaseRepos) {
        	if (validprop('releaseReposUser')&&validprop('releaseReposPasswd')) {
        		authentication(userName: releaseReposUser, password: releaseReposPasswd)
        	}
        }
      }
      if (validprop('snapshotRepos')) {
        snapshotRepository(url: snapshotRepos) {
        	if (validprop('snapshotReposUser')&&validprop('snapshotReposPasswd')) {
        		authentication(userName: snapshotReposUser, password: snapshotReposPasswd)
        	}
        }
      }
    }
  }
}

uploadAllInOne {
	dependsOn uberjme
	repositories {
    mavenDeployer {
  		if (validprop('releaseRepos')) {
        repository(url: releaseRepos) {
        	if (validprop('releaseReposUser')&&validprop('releaseReposPasswd')) {
        		authentication(userName: releaseReposUser, password: releaseReposPasswd)
        	}
        }
      }
      if (validprop('snapshotRepos')) {
        snapshotRepository(url: snapshotRepos) {
        	if (validprop('snapshotReposUser')&&validprop('snapshotReposPasswd')) {
        		authentication(userName: snapshotReposUser, password: snapshotReposPasswd)
        	}
        }
      }
    }
  }
}

uploadPublish {
	dependsOn obfuscate
	repositories {
    mavenDeployer {
  		if (validprop('releaseRepos')) {
        repository(url: releaseRepos) {
        	if (validprop('releaseReposUser')&&validprop('releaseReposPasswd')) {
        		authentication(userName: releaseReposUser, password: releaseReposPasswd)
        	}
        }
      }
      if (validprop('snapshotRepos')) {
        snapshotRepository(url: snapshotRepos) {
        	if (validprop('snapshotReposUser')&&validprop('snapshotReposPasswd')) {
        		authentication(userName: snapshotReposUser, password: snapshotReposPasswd)
        	}
        }
      }
    }
  }
}

task mtj {
	dependsOn 'eclipse'
	doLast {
		writeAppDesc(file('Application Descriptor'))
	}
}

mtj << {
	file('.mtj').write """<?xml version="1.0" encoding="UTF-8"?>
<mtjMetadata version="1.2.1.v201009031435">
   <signing projectSpecific="false" signProject="false">
      <alias/>
   </signing>
   <configurations>
      <configuration active="true" name="iptv">
         <device group="Sun Java(TM) Wireless Toolkit 2.5.2_01 for CLDC" name="DefaultColorPhone"/>
         <symbolSet name="DefaultColorPhone">
            <symbol name="screen.isColor" value="true"/>
            <symbol name="MMAPI" value="1.1"/>
            <symbol name="screen.bitDepth" value="8"/>
            <symbol name="JSR82" value="1.1"/>
            <symbol name="JSR226" value="1.0"/>
            <symbol name="MIDP" value="2.0"/>
            <symbol name="JSR229" value="1.1"/>
            <symbol name="SATSA-PKI" value="1.0"/>
            <symbol name="CLDC" value="1.1"/>
            <symbol name="JSR179" value="1.0"/>
            <symbol name="WMA" value="2.0"/>
            <symbol name="SATSA-JCRMI" value="1.0"/>
            <symbol name="J2ME-WS" value="1.0"/>
            <symbol name="screen.width" value="240"/>
            <symbol name="JSR238" value="1.0"/>
            <symbol name="JSR239" value="1.0"/>
            <symbol name="screen.isTouch" value="false"/>
            <symbol name="JSR211" value="1.0"/>
            <symbol name="JSR234" value="1.0"/>
            <symbol name="SATSA-APDU" value="1.0"/>
            <symbol name="JSR75" value="1.0"/>
            <symbol name="J2ME-XMLRPC" value="1.0"/>
            <symbol name="JSR184" value="1.1"/>
            <symbol name="SATSA-CRYPTO" value="1.0"/>
            <symbol name="version.configuration" value="CLDC-1.1"/>
            <symbol name="version.profile" value="MIDP-2.1"/>
            <symbol name="JSR180" value="1.0"/>
            <symbol name="screen.height" value="320"/>
         </symbolSet>
      </configuration>
   </configurations>
</mtjMetadata>"""
}

eclipse.classpath.file {
    whenMerged { classpath ->
        classpath.entries.removeAll { entry -> entry.kind == 'con' }
    }
}

